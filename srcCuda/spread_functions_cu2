#include "spread_functions.hpp"

#define _USE_MATH_DEFINES
#include <cmath>
#include <random>
#include <vector>
#include <cuda_runtime.h>
#include <curand_kernel.h>
#include <thrust/device_vector.h>
#include <thrust/host_vector.h>

#include "fires.hpp"
#include "landscape.hpp"

// Helper function for CUDA error checking
#define CUDA_CHECK(call) \
    do { \
        cudaError_t error = call; \
        if (error != cudaSuccess) { \
            fprintf(stderr, "CUDA error at %s:%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(error)); \
            exit(1); \
        } \
    } while(0)

__device__ float spread_probability(
    const Cell& burning, const Cell& neighbour, SimulationParams params, float angle,
    float distance, float elevation_mean, float elevation_sd, float upper_limit = 1.0
) {
    float slope_term = sin(atan((neighbour.elevation - burning.elevation) / distance));
    float wind_term = cos(angle - burning.wind_direction);
    float elev_term = (neighbour.elevation - elevation_mean) / elevation_sd;
    float linpred = params.independent_pred;

    if (neighbour.vegetation_type == SUBALPINE) {
        linpred += params.subalpine_pred;
    } else if (neighbour.vegetation_type == WET) {
        linpred += params.wet_pred;
    } else if (neighbour.vegetation_type == DRY) {
        linpred += params.dry_pred;
    }

    linpred += params.fwi_pred * neighbour.fwi;
    linpred += params.aspect_pred * neighbour.aspect;
    linpred += wind_term * params.wind_pred + elev_term * params.elevation_pred +
        slope_term * params.slope_pred;

    float prob = upper_limit / (1 + exp(-linpred));

    return prob;
}

// CUDA kernel for spread probability calculation
// Each thread processes one cell, if some of its neighbors are burning,
// it calculates the probability of burning itself based on the parameters
__global__ void calculate_spread_probabilities(
    const Cell* landscape,
    unsigned int* burned_ids,
    const unsigned int* burning_cells,
    unsigned int* burned_size,
    const unsigned int* burned_step,
    unsigned int n_col,
    unsigned int n_row,
    const SimulationParams* params,
    float distance,
    float elevation_mean,
    float elevation_sd,
    float upper_limit,
    curandState* states,
    bool* burned_bin,
    unsigned int* new_burning_cells,
    unsigned int* new_burned_step
) {
    const float angles[8] = { M_PI * 3 / 4, M_PI, M_PI * 5 / 4, M_PI / 2, M_PI * 3 / 2,
                              M_PI / 4,     0,    M_PI * 7 / 4 };
    const int moves[8][2] = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 },
                              { 0, 1 },   { 1, -1 }, { 1, 0 },  { 1, 1 } };

    unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= *burned_step) return;

    // Get burning cell coordinates
    unsigned int burning_cell_0 = burning_cells[idx * 2];
    unsigned int burning_cell_1 = burning_cells[idx * 2 + 1];
    if (burning_cell_0 >= n_col || burning_cell_1 >= n_row) return;

    const Cell& burning_cell = landscape[burning_cell_1 * n_col + burning_cell_0];

    // Get the random state for this cell
    unsigned int cell_idx = burning_cell_1 * n_col + burning_cell_0;
    curandState localState = states[cell_idx];

    // Process each neighbor
    for (int n = 0; n < 8; n++) {
        int neighbor_x = burning_cell_0 + moves[n][0];
        int neighbor_y = burning_cell_1 + moves[n][1];

        // Check if neighbor is in range
        if (neighbor_x < 0 || neighbor_x >= n_col || neighbor_y < 0 || neighbor_y >= n_row) {
            continue;
        }

        // Check if already burned
        if (burned_bin[neighbor_y * n_col + neighbor_x]) {
            continue;
        }

        const Cell& neighbor = landscape[neighbor_y * n_col + neighbor_x];
        if (!neighbor.burnable) {
            continue;
        }

        float prob = spread_probability(
            burning_cell, neighbor, *params, angles[n], distance, elevation_mean, elevation_sd, upper_limit
        );

        // Random number generation and burn decision
        float random_value = curand_uniform(&localState);

        if (random_value < prob) {
            // Atomically add new burned cell
            unsigned int new_idx = atomicAdd(burned_size, 1);
            burned_ids[new_idx * 2] = neighbor_x;
            burned_ids[new_idx * 2 + 1] = neighbor_y;

            unsigned int new_burning_idx = atomicAdd(new_burned_step, 1);
            new_burning_cells[new_burning_idx * 2] = neighbor_x;
            new_burning_cells[new_burning_idx * 2 + 1] = neighbor_y;
            burned_bin[neighbor_y * n_col + neighbor_x] = true;
        }
    }
    // Save the updated random state
    states[cell_idx] = localState;
}

// Initialize random states
__global__ void init_random_states(curandState* states, unsigned int seed) {
    unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x;
    curand_init(seed, idx, 0, &states[idx]);
}

Fire simulate_fire(
    const Landscape& landscape, const std::vector<std::pair<unsigned int, unsigned int>>& ignition_cells,
    SimulationParams params, float distance, float elevation_mean, float elevation_sd,
    float upper_limit = 1.0
) {
    // Use CUDA timing instead of OpenMP
    cudaEvent_t start_event, stop_event;
    CUDA_CHECK(cudaEventCreate(&start_event));
    CUDA_CHECK(cudaEventCreate(&stop_event));
    CUDA_CHECK(cudaEventRecord(start_event));

    unsigned int n_row = landscape.height;
    unsigned int n_col = landscape.width;

    // Initialize host arrays
    // std::vector<std::pair<unsigned int, unsigned int>> burned_ids;
    // std::vector<unsigned int> burned_ids_steps;
    //Matrix<bool> burned_bin(n_col, n_row);

    // Host variables
    Matrix<bool> burned_bin(n_col, n_row);
    std::vector<std::pair<unsigned int, unsigned int>> burned_ids;
    std::vector<unsigned int> burned_ids_steps;
    unsigned int burned_size = 0;

    // Device variables
    unsigned int* d_burned_size;
    unsigned int* d_burned_step;
    unsigned int* d_new_burned_step;
    bool* d_burned_bin = nullptr;
    unsigned int* d_burned_ids = nullptr;
    unsigned int* d_burning_cells = nullptr;
    unsigned int* d_new_burning_cells = nullptr;
    Cell* d_landscape = nullptr;
    curandState* d_states = nullptr;
    SimulationParams* d_params = nullptr;

    // Variables sizes
    size_t d_burned_ids_size = 2 * n_col * n_row * sizeof(unsigned int);
    size_t landscape_size = n_col * n_row * sizeof(Cell);
    size_t burned_bin_size = n_col * n_row * sizeof(bool);

    // Allocate device memory with error checking
    CUDA_CHECK(cudaMalloc(&d_burned_size, sizeof(unsigned int)));
    CUDA_CHECK(cudaMalloc(&d_burned_step, sizeof(unsigned int)));
    CUDA_CHECK(cudaMalloc(&d_new_burned_step, sizeof(unsigned int)));
    CUDA_CHECK(cudaMalloc(&d_burned_bin, burned_bin_size));
    CUDA_CHECK(cudaMalloc(&d_burned_ids, d_burned_ids_size));
    CUDA_CHECK(cudaMalloc(&d_burning_cells, d_burned_ids_size));
    CUDA_CHECK(cudaMalloc(&d_new_burning_cells, d_burned_ids_size));
    CUDA_CHECK(cudaMalloc(&d_landscape, landscape_size));
    CUDA_CHECK(cudaMalloc(&d_states, n_col * n_row * sizeof(curandState)));
    CUDA_CHECK(cudaMalloc(&d_params, sizeof(SimulationParams)));

    // Initialize device memory to zero
    CUDA_CHECK(cudaMemset(d_burned_ids, 0, d_burned_ids_size));

    bool* burned_bin_aux = new bool[n_col * n_row];

    for (unsigned int i = 0; i < n_col * n_row; i++) {
        burned_bin_aux[i] = false;
    }

    unsigned int* burning_cells = new unsigned int[2 * n_col * n_row];

    // Add ignition cells
    for (const auto& cell : ignition_cells) {
        burned_bin_aux[cell.first + cell.second * n_col] = true;
        burning_cells[2 * burned_size] = cell.first;
        burning_cells[2 * burned_size + 1] = cell.second;
        burned_size++;
        burned_ids.push_back(cell);
    }
    burned_ids_steps.push_back(burned_size);
    CUDA_CHECK(cudaMemcpy(d_burned_size, &burned_size, sizeof(unsigned int), cudaMemcpyHostToDevice));
    CUDA_CHECK(cudaMemcpy(d_burned_step, d_burned_size, sizeof(unsigned int), cudaMemcpyDeviceToDevice));
    CUDA_CHECK(cudaMemcpy(d_burned_bin, burned_bin_aux, n_col * n_row * sizeof(bool), cudaMemcpyHostToDevice));
    CUDA_CHECK(cudaMemcpy(d_burned_ids, burning_cells, 2 * burned_size * sizeof(unsigned int), cudaMemcpyHostToDevice));
    CUDA_CHECK(cudaMemcpy(d_burning_cells, burning_cells, 2 * burned_size * sizeof(unsigned int), cudaMemcpyHostToDevice));

    delete[] burning_cells;

    // Copy params to device
    CUDA_CHECK(cudaMemcpy(d_params, &params, sizeof(SimulationParams), cudaMemcpyHostToDevice));

    // Copy landscape to device
    Cell* landscape_data = new Cell[n_col * n_row];
    if (!landscape_data) {
        fprintf(stderr, "Failed to allocate landscape_data\n");
        exit(1);
    }
    for (unsigned int i = 0; i < n_col; i++) {
        for (unsigned int j = 0; j < n_row; j++) {
            landscape_data[j * n_col + i] = landscape[{i, j}];
        }
    }
    CUDA_CHECK(cudaMemcpy(d_landscape, landscape_data, landscape_size, cudaMemcpyHostToDevice));

    // Initialize random states
    int block_size = 512;
    size_t total = n_col * n_row;
    int num_blocks = (total + block_size - 1) / block_size;
    init_random_states<<<num_blocks, block_size>>>(d_states, time(NULL));

    CUDA_CHECK(cudaGetLastError());
    CUDA_CHECK(cudaDeviceSynchronize());
    
    while (true) {
        CUDA_CHECK(cudaMemset(d_new_burned_step, 0, sizeof(unsigned int)));

        calculate_spread_probabilities<<<num_blocks, block_size>>>(
            d_landscape, d_burned_ids, d_burning_cells, d_burned_size, d_burned_step,
            n_col, n_row, d_params, distance, elevation_mean, elevation_sd,
            upper_limit, d_states, d_burned_bin, d_new_burning_cells, d_new_burned_step
        );

        cudaError_t e = cudaGetLastError();
        cudaDeviceSynchronize();
        if (e != cudaSuccess) {
        fprintf(stderr, "Error justo después del kernel: %s\n", cudaGetErrorString(e));
        }

        unsigned int burned_step;
        CUDA_CHECK(cudaMemcpy(&burned_step, d_new_burned_step, sizeof(unsigned int), cudaMemcpyDeviceToHost));

        if (!burned_step)
            break;

        burned_ids_steps.push_back(burned_step);

        CUDA_CHECK(cudaMemcpy(d_burning_cells, d_new_burning_cells, 2 * burned_step * sizeof(unsigned int), cudaMemcpyDeviceToDevice));
        CUDA_CHECK(cudaMemcpy(d_burned_step, d_new_burned_step, sizeof(unsigned int), cudaMemcpyDeviceToDevice));
    }

    CUDA_CHECK(cudaMemcpy(&burned_size, d_burned_size, sizeof(unsigned int), cudaMemcpyDeviceToHost));

    CUDA_CHECK(cudaMemcpy(burned_bin_aux, d_burned_bin, n_col * n_row * sizeof(bool), cudaMemcpyDeviceToHost));
    for (unsigned int i = 0; i < n_col * n_row; i++) {
        burned_bin[{i % n_col, i / n_col}] = burned_bin_aux[i];
    }

    unsigned int* h_burned_ids_aux = new unsigned int[burned_size * 2];
    CUDA_CHECK(cudaMemcpy(h_burned_ids_aux, d_burned_ids, burned_size * 2 * sizeof(unsigned int), cudaMemcpyDeviceToHost));
    for (unsigned int i = 0; i < 2 * burned_size; i += 2) {
        burned_ids.push_back({h_burned_ids_aux[i], h_burned_ids_aux[i + 1]});
    }
    
    // Get elapsed time using CUDA events
    CUDA_CHECK(cudaEventRecord(stop_event));
    CUDA_CHECK(cudaEventSynchronize(stop_event));
    float milliseconds = 0;
    CUDA_CHECK(cudaEventElapsedTime(&milliseconds, start_event, stop_event));
    double seconds = milliseconds / 1000.0;

    //fprintf(stderr, "Celdas incendiadas: %u\n", burned_size);
    //fprintf(stderr, "celdas incendiadas por microsegundo: %lf\n", burned_size / (1E06 * seconds));

    // Free device memory
    if (d_landscape) CUDA_CHECK(cudaFree(d_landscape));
    if (d_states) CUDA_CHECK(cudaFree(d_states));
    if (d_params) CUDA_CHECK(cudaFree(d_params));
    if (d_burned_ids) CUDA_CHECK(cudaFree(d_burned_ids));
    if (d_burned_size) CUDA_CHECK(cudaFree(d_burned_size));
    if (d_burned_step) CUDA_CHECK(cudaFree(d_burned_step));
    if (d_burning_cells) CUDA_CHECK(cudaFree(d_burning_cells));
    if (d_burned_bin) CUDA_CHECK(cudaFree(d_burned_bin));

    // Clean up CUDA events
    CUDA_CHECK(cudaEventDestroy(start_event));
    CUDA_CHECK(cudaEventDestroy(stop_event));


    delete[] landscape_data;
    delete[] h_burned_ids_aux;

    return { n_col, n_row, burned_bin, burned_ids, burned_ids_steps };
}
